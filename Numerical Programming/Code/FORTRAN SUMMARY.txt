FORTRAN

- starting and ending the program:
  PROGRAM <name>
  END PROGRAM <name>

- comments
  ! comment

- variable types
  > TYPES: INTEGER, REAL, COMPLEX, LOGICAL, CHARACTER (LEN=size)
  > type, DIMENSION(size) - for arrays
  > declaring variables
    type :: variable
  > IMPLICIT NONE - to avoid implicit declaration
  > derived types:
    TYPE typename
	...
	type :: variable
	...
    END TYPE typename
  > initializing variables
	variable = value
	array(:) = <value> - all array values will be <value>
	array(position) = value
	character = ''
	logical = .TRUE./.FALSE.

- control structures
  > DO counter start, end
	...
    END DO
  > IF (condition) THEN
      ...
	ELSE
	...
      EXIT
    END IF
  > .AND., .OR.
  > MOD(num1, num2)
  > /= -> not equal to
  > alternative operators: .LT., .LE., .EQ., .NE., .GE., .GT.

- I/O
  > PRINT *, variable/"text"  - cursor stops at newline
    or
    WRITE(*, FMT = '(A)', ADVANCE = "NO") - cursor stops at end of prompt
    or 
   WRITE(*,*)
  > READ(*,*) variable
  > COMMAND_ARGUMENT_COUNT() - returns number of command line arguments
  > GET_COMMAND_ARGUMENT(number, character) - 

RETURN TO p. 14

- FILE I/O
  > OPEN(UNIT, FILE, FORM, IOSTAT)

RETURN TO p. 17

- FUNCTIONS
  > FUNCTION function_name(args) RESULT(variable)
	...
	type, INTENT(IN) :: variable - read-only, prevents overwriting of input argument
	type, INTENT(OUT) :: variable - write-only
	...
    END FUNCTION function_name
  > RETURN
  > CALL function(name, output_var)

- SUBROUTINES
  > SUBROUTINE subroutine_name(arguments)
    ...
    type, INTENT(IN) :: variable
    type, INTENT(OUT) :: variable
    ...
    END SUBROUTINE subroutine_name

- ARRAYS & POINTERS
  > SAMPLE CODE
	REAL, TARGET, DIMENSION(10,10) :: matrix
	REAL, TARGET, ALLOCATABLE, DIMENSION(:,:) :: matrix2
	REAL, POINTER :: p(:,:)
	...
	ALLOCATIE(matrix2(20,20)
	p => matrix(2:3,2:3)
	p => matrix2(10:12,18:20)

- MODULES

- DERIVED DATA TYPES 